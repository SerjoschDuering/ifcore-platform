# Frontend Architecture

React 19 + TypeScript app. Each feature (upload, checks, 3D viewer) is a
**feature module** — a colocated folder with components + hooks. Backend
operations are **async jobs**.

> **New to web development?** A frontend is the part users see and click on
> (the website). The backend is the server doing the heavy work (running checks).
> They talk to each other through an **API** — a set of URLs the frontend
> calls to send or receive data.

## Structure

```
src/
├── main.tsx              ← React entry + router
├── routeTree.gen.ts      ← auto-generated by TanStack Router plugin
│
├── routes/               ← file-based routing (auto code-split)
│   ├── __root.tsx        ← layout: Navbar + <Outlet>
│   ├── index.tsx         ← / → redirect to /projects
│   ├── projects.tsx      ← /projects layout wrapper
│   ├── projects.index.tsx← project list + upload form
│   ├── projects.$id.tsx  ← project detail: checks + results
│   ├── checks.tsx        ← all check results
│   └── viewer.tsx        ← 3D viewer (lazy-loads R3F)
│
├── features/             ← feature modules (colocated)
│   ├── upload/
│   │   ├── UploadForm.tsx
│   │   └── useUpload.ts
│   ├── checks/
│   │   ├── CheckRunner.tsx
│   │   ├── ResultsTable.tsx
│   │   └── useChecks.ts
│   └── viewer/
│       ├── BIMViewer.tsx  ← ThatOpen Components IFC viewer
│       └── useViewer.ts   ← syncs check results → colorMap
│
├── stores/
│   ├── store.ts          ← combined Zustand store
│   └── slices/
│       ├── projectsSlice.ts
│       ├── checksSlice.ts
│       ├── jobsSlice.ts
│       └── viewerSlice.ts ← 3D viewer state (ifcUrl, colorMap, selection)
│
├── lib/
│   ├── api.ts            ← typed fetch wrapper for /api/*
│   ├── poller.ts         ← polls running jobs every 2s
│   └── types.ts          ← shared TS types
│
├── components/           ← shared UI
│   ├── Navbar.tsx
│   ├── StatusBadge.tsx
│   └── LoadingSpinner.tsx
│
└── styles/
    └── globals.css
```

## Routing (TanStack Router)

File-based routing — each file in `src/routes/` becomes a route automatically.
The `@tanstack/router-plugin` Vite plugin generates `routeTree.gen.ts`.

> **What's a router?** It watches the URL in the browser. When the URL says
> `/checks`, it shows the checks page. When it says `/viewer`, it shows
> the 3D viewer. Each "page" is a route, but it's all one app — no page reloads.

```
┌──────────────────────────────────────┐
│  Nav:  Projects | Checks | 3D        │
├──────────────────────────────────────┤
│   ← active route renders here →      │
└──────────────────────────────────────┘
```

Adding a route: create `src/routes/yourpage.tsx` with:
```tsx
import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/yourpage")({
  component: () => <div>Your page content</div>,
});
```
The router plugin auto-discovers it. No manual registration needed.

## Async Job Pattern

Backend tasks (IFC checks, AI agents) take 10-60 seconds. Everything uses **async jobs**.

> **What's async?** Normally when you click a button, the browser waits for
> the server to respond — that's synchronous. But if the server needs 30 seconds,
> the browser would freeze. **Async** means: "start the work, come back and check
> later." The server returns a job ID immediately, and the frontend keeps
> checking ("polling") until the job is done.

```
Frontend           Worker (proxy)      HF Space (FastAPI)
────────           ──────────────      ──────────────────
POST /check  ───>  proxy         ───>  start background task
             <───  {jobId}       <───  return {jobId} immediately

poll GET /jobs/id  read D1              ...working...
             <───  {status:"running"}

poll GET /jobs/id  read D1        ───>  POST /jobs/id/callback
             <───  {status:"done", data:[...]}
```

**Why this pattern?** The CF Worker has a 10ms CPU limit on the free tier —
it physically can't wait 30 seconds. So it just reads/writes to the database
and returns. The heavy work happens on the HF Space.

> **What's a callback?** When the HF Space finishes, it calls the Worker
> back ("hey, job X is done, here are the results"). The Worker writes
> the results to the database. Next time the frontend polls, it gets them.

### Recipe: Adding a New Async Endpoint

Three layers. Always the same pattern.

| Layer | What to add |
|-------|-------------|
| **HF Space** `main.py` | `POST /your-thing` → starts `BackgroundTasks`, returns `{jobId}`. When done, POSTs results to callback URL. |
| **Worker** route | Proxy route for `POST /api/your-thing`. Job tracking (`GET /api/checks/jobs/:id`, callback) is shared. |
| **Frontend** `api.ts` | `startYourThing(args)` → returns `{job_id}`. Call `store.trackJob(...)` + `startPolling()`. |

> **What's an endpoint?** A specific URL the server listens on. `POST /check`
> is an endpoint. `GET /jobs/123` is another. Think of them as doors into the
> backend — each door does one thing.

## Shared State (Zustand)

Zustand store with **slices pattern** — each feature has its own slice, combined in `store.ts`.

> **What's state?** The data your app is currently showing. "Which project is
> selected? Are checks running? What were the results?" That's all state.
> Without a shared store, each feature would have its own copy and they'd
> get out of sync. Zustand keeps one source of truth.

**How features use it:**
- **Upload** sets projects, starts a job → `trackJob(job)`
- **Checks** reads `checkResults`, `elementResults` → renders a table
- **3D Viewer** reads element results → highlights failing elements in red
- **Dashboard** reads results → shows charts and stats

```typescript
// stores/store.ts — combined store
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import { createProjectsSlice } from "./slices/projectsSlice";
import { createChecksSlice } from "./slices/checksSlice";
import { createJobsSlice } from "./slices/jobsSlice";

export const useStore = create(devtools((...a) => ({
  ...createProjectsSlice(...a),
  ...createChecksSlice(...a),
  ...createJobsSlice(...a),
})));
```

**Adding new state:** Create a new slice in `stores/slices/`, add it to `store.ts`.

**API client** (`lib/api.ts`): all features go through this — never call `fetch()` directly.

> **What's `fetch()`?** The browser's built-in way to call an API. `lib/api.ts`
> wraps it so you don't repeat the base URL and error handling everywhere.

## Feature Module Pattern

Features are React components with colocated hooks:

```tsx
// features/upload/UploadForm.tsx
export function UploadForm() {
  const { upload, isUploading } = useUpload();
  // ... render form
}

// features/upload/useUpload.ts
export function useUpload() {
  // Uses api.ts for HTTP, useStore for state
}
```

**Rules:**
- Don't import from other feature modules
- Read/write state through `useStore`
- Call backend through `lib/api.ts`
- One folder, one concern

## 3D Viewer (ThatOpen Components)

The viewer renders IFC files directly in the browser using `@thatopen/components` v3.
No backend GLB conversion — IFC is fetched from R2 and parsed client-side via `web-ifc` WASM.

> **WASM loading is tricky.** web-ifc uses Emscripten WASM that breaks when processed
> by any bundler. The platform uses an IIFE script tag + shim pattern to load it outside
> the bundle. See [3D Viewer Reference](./3d-viewer.md) for the full pattern.

The viewer is driven by `viewerSlice` in the Zustand store:
- `ifcUrl` — set by the route loader, triggers IFC fetch + render
- `colorMap` — GlobalId → hex color, applied via `FragmentsManager.highlight()`
- `selectedIds` / `hiddenIds` — for element selection and visibility toggling

```
Upload IFC → R2 → route sets ifcUrl → BIMViewer loads IFC → GUID map built
Run checks → results → useViewer computes colorMap → BIMViewer highlights elements
```

See [3D Viewer](./3d-viewer.md) for architecture details, the WASM loading pattern,
and how to extend the viewer.

## Database (D1)

> **What's D1?** Cloudflare's database service. It runs SQLite (a simple
> database that stores data in tables, like a spreadsheet). The frontend
> never talks to D1 directly — it goes through the Worker API.

```sql
CREATE TABLE users (
  id TEXT PRIMARY KEY,
  name TEXT,
  team TEXT,                     -- e.g. "ifcore-team-a", nullable
  created_at INTEGER
);

CREATE TABLE projects (
  id TEXT PRIMARY KEY,
  user_id TEXT REFERENCES users(id),
  name TEXT,
  file_url TEXT,
  ifc_schema TEXT,               -- e.g. "IFC4", null if unknown
  region TEXT,                   -- e.g. "CH", null if unknown
  building_type TEXT,            -- e.g. "residential", null
  metadata TEXT,                 -- JSON blob, nullable
  created_at INTEGER
);

CREATE TABLE check_results (
  id TEXT PRIMARY KEY,
  project_id TEXT REFERENCES projects(id),
  job_id TEXT,                   -- groups results from one run
  check_name TEXT,               -- e.g. "check_door_width"
  team TEXT,                     -- e.g. "ifcore-team-a"
  status TEXT DEFAULT 'running', -- pass | fail | unknown | error | running
  summary TEXT,                  -- "14 doors: 12 pass, 2 fail"
  has_elements INTEGER DEFAULT 0,
  created_at INTEGER
);

CREATE TABLE element_results (
  id TEXT PRIMARY KEY,
  check_result_id TEXT REFERENCES check_results(id),
  element_id TEXT,               -- IFC GlobalId (nullable)
  element_type TEXT,             -- e.g. "IfcDoor" (nullable)
  element_name TEXT,             -- e.g. "Door #42" (nullable)
  element_name_long TEXT,        -- e.g. "Door #42 (Level 1, Zone A)" (nullable)
  check_status TEXT,             -- pass | fail | warning | blocked | log
  actual_value TEXT,             -- e.g. "750 mm"
  required_value TEXT,           -- e.g. "800 mm"
  comment TEXT,                  -- human-readable explanation (nullable)
  log TEXT                       -- debug/trace info (nullable)
);
```

`jobs` table tracks async job state — see `migrations/0001_init.sql` for full DDL.

See [Validation Schema](./validation-schema.md) for how team `list[dict]` output maps to these rows.

> **What's a migration?** A file that changes the database structure
> (adds a table, adds a column). You run it once with `wrangler d1 execute`.
> It's like a recipe for the database — run it, and the new table exists.

## Adding a Feature (Checklist)

1. Create `src/features/<name>/` with component(s) + hook(s)
2. Create `src/routes/<route>.tsx` with `createFileRoute`
3. If it needs new state → add a slice to `stores/slices/`
4. If it needs a new API call → add to `lib/api.ts`
5. If it needs a new backend endpoint → follow async recipe above

## PRD Review (Thursday)

> **What's a PRD?** Product Requirements Document — a short plan describing
> what you're building, why, and what "done" looks like. Doesn't need to be
> fancy. Half a page is fine.

Before building, each team writes a PRD for their feature. All reviewed together:
- What each team builds
- What async endpoints are needed
- What shared state each feature expects
- Whether features overlap
